{"componentChunkName":"component---src-templates-lesson-template-js","path":"/layers","webpackCompilationHash":"b2034472b79bf4d99eae","result":{"data":{"markdownRemark":{"html":"<h2 id=\"layers\"><a href=\"#layers\" aria-label=\"layers permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layers</h2>\n<p>Go make any change to your Node.js app. Now re-run your build process. Docker is smart enough to see the your <code class=\"language-text\">FROM</code>, <code class=\"language-text\">RUN</code>, and <code class=\"language-text\">WORKDIR</code> instructions haven't changed and wouldn't change if you ran them again so it uses the same containers it cached from the previous but it can see that your <code class=\"language-text\">COPY</code> is different since files changed between last time and this time, so it begins the build process there and re-runs all instructinos after that. Pretty smart, right?</p>\n<p>So which part of container-building takes the longest? <code class=\"language-text\">RUN npm ci</code>. Anything that has to hit the network is going to take the longest without-a-doubt. The shame is that our <code class=\"language-text\">package.json</code> hasn't changed since the previous iteration; we just changed something in our <code class=\"language-text\">index.js</code>. So how we make it so we only re-run our <code class=\"language-text\">npm ci</code> when package.json changes? Break it into two <code class=\"language-text\">COPY</code> instructions!</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>12<span class=\"token punctuation\">-</span>stretch\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>chown=node<span class=\"token punctuation\">:</span>node package<span class=\"token punctuation\">-</span>lock.json package.json ./\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>chown=node<span class=\"token punctuation\">:</span>node . .\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The first <code class=\"language-text\">COPY</code> pulls just the <code class=\"language-text\">package.json</code> and the <code class=\"language-text\">package-lock.json</code> which is just enough to do the <code class=\"language-text\">npm ci</code>. After that we nab the rest of the files. Now if you make changes you avoid doing a full npm install. This is useful and recommended for any dependency installation: apt-get, pip, cargo, gems, etc. as well as any long-running command like building some from source.</p>","frontmatter":{"path":"/layers","title":"Layers","order":4.5,"section":"The Dockerfile","description":"Brian goes into depth about what layers are with regard to Docker images and how you can leverage Docker's caching of layers to more quickly rebuild containers"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":9,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}