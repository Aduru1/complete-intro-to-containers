{"componentChunkName":"component---src-templates-lesson-template-js","path":"/going-to-production","webpackCompilationHash":"286b45493ff69f62f994","result":{"data":{"markdownRemark":{"html":"<p>We've now built a nice little container for our Node.js app and we absolutely could ship it as-is to production. However there's a few things we can do to make things even faster, cheaper, and more secure.</p>\n<h2 id=\"making-your-containers-smaller\"><a href=\"#making-your-containers-smaller\" aria-label=\"making your containers smaller permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Making your containers smaller</h2>\n<p>Making your containers smaller is a good thing for a few reasons. For one, everything tends to get a bit cheaper. Moving containers across the Internet takes time and bits to do. If you can make those containers smaller, things will go faster and you'll require less space on your servers. Often private container registries (like personal Docker Hubs, Azure Container Registry is a good example) often charge you by how much storage you're using.</p>\n<p>Beyond that, having less <em>things</em> in your container means you're less susceptible to bugs. Let's say there's a Python exploit that's going around that allows hackers to get root access to your container. If you don't have Python in your container, you're not vulnerable! And obviously if you do have Python installed (even if you're not using it) you're vulnerable. So let's see how to make your container a bit smaller.</p>\n<p>In your previous Dockerfile, change the first line (<code class=\"language-text\">FROM</code>)</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>alpine\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> package<span class=\"token punctuation\">-</span>lock.json package.json ./\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Our image size (by comparing the <code class=\"language-text\">&quot;Size&quot;</code> field in in <code class=\"language-text\">docker inspect my-app</code>) from 913MB to 86MB just like that. We shed quite a bit of cruft that we didn't need in Ubuntu and we didn't even need to change anything in our Dockerfile. Honestly, that's unusual. When you strip <em>everything</em> out typically you'll have to go back and add some of them back in. But in this case we're golden!</p>\n<p>Alpine, if you remember, is a bare bones alternative to Ubuntu. It's built on Busybox Linux which is a 2MB distro of Linux (Alpine is 5MB.) <code class=\"language-text\">node:alpine</code> itself is about <code class=\"language-text\">80MB</code> and <code class=\"language-text\">node:latest is about 908MB</code>.</p>\n<h2 id=\"making-our-own-nodejs-alpine-container\"><a href=\"#making-our-own-nodejs-alpine-container\" aria-label=\"making our own nodejs alpine container permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Making our own Node.js Alpine container</h2>\n<p>Let's take this exercise a bit further. Let's actually make our own Node.js Alpine container. NOTE: I'd suggest always using the official one. They'll keep it up to date with security fixes and they're <em>real</em> good at making containers. Better than I am, anyway. But this is a good exercise for us to go through to learn how to install system dependencies.</p>\n<p>Start with this in a new Dockerfile. You can call it <code class=\"language-text\">my-node.Dockerfile</code>. Some people will insist it should be <code class=\"language-text\">Dockerfile.my-node</code> but the former doesn't break syntax highlighting and it doesn't matter since Docker doesn't actually care.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>3.10\n\n<span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update nodejs npm</code></pre></div>\n<p><code class=\"language-text\">alpine:latest</code> would nab you the latest Alpine (3.10 as of writing, if you run into issues with versions, continue with <code class=\"language-text\">alpine:3.10</code> instead of <code class=\"language-text\">alpine:latest</code>. Otherwise feel free to truck on with <code class=\"language-text\">alpine:latest</code>)</p>\n<p><code class=\"language-text\">RUN apk add --update nodejs npm</code> will use the Alpine package manager to grab Node.js and npm (they're bundled separately for Alpine.)</p>\n<p>Okay so now if you do <code class=\"language-text\">docker build -t my-node -f my-node.Dockerfile .</code> it'll build your new image. <code class=\"language-text\">-t</code> is <code class=\"language-text\">--tag</code> and <code class=\"language-text\">-f</code> is <code class=\"language-text\">--file</code> which is what tells Docker is the name of your Dockerfile you're using (otherwise it assumes you're using a file called exactly <code class=\"language-text\">Dockerfile</code>.) Now try <code class=\"language-text\">docker run -it my-node</code>. In here you should have a pretty bare bones Linux container but both <code class=\"language-text\">node -v</code> and <code class=\"language-text\">npm -v</code> should work.</p>\n<p>Keep in mind that Alpine does not use bash for its shell; it uses a different shell called <code class=\"language-text\">ash</code> or often just <code class=\"language-text\">sh</code>. It's similar enough to bash but there are some differences. It's not really the point of this class so we'll keep the focus on learning just what's necessary.</p>\n<p>Let's next make our <code class=\"language-text\">node</code> user.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>3.10\n\n<span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update nodejs npm\n\n<span class=\"token keyword\">RUN</span> addgroup <span class=\"token punctuation\">-</span>S node &amp;&amp; adduser <span class=\"token punctuation\">-</span>S node <span class=\"token punctuation\">-</span>G node\n\n<span class=\"token keyword\">USER</span> node</code></pre></div>\n<p>I'm mimicking what the Node.js official container does, which is make a user group of <code class=\"language-text\">node</code> with one user in it, <code class=\"language-text\">node</code>. Feel free to name them different things if you feel so inclined. Notice we could conceivably combine the two <code class=\"language-text\">RUN</code> instructions together but it's generally best practices to keep \"ideas\" separate. The first <code class=\"language-text\">RUN</code> installs dependencies, the second one creates the <code class=\"language-text\">node</code> user. Up to you how you do it, neither is wrong per se.</p>\n<p>Now we can just copy the rest from the previous Dockerfile! Let's do that.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>3.10\n\n<span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update nodejs npm\n\n<span class=\"token keyword\">RUN</span> addgroup <span class=\"token punctuation\">-</span>S node &amp;&amp; adduser <span class=\"token punctuation\">-</span>S node <span class=\"token punctuation\">-</span>G node\n\n<span class=\"token keyword\">USER</span> node\n\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n\n<span class=\"token keyword\">COPY</span> package<span class=\"token punctuation\">-</span>lock.json package.json ./\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>It works! We're down to 56MB (compared to 86MB with the official <code class=\"language-text\">node:alpine</code> container). Honestly, I'm not entirely sure what we cut out from the other <code class=\"language-text\">node:alpine</code> container but it's probably important. Again, I'd stick to the official containers where they exist. But hey, we learned how to add a user and install system dependencies! Let's make it even small because why the hell not.</p>\n<h2 id=\"multi-stage-builds\"><a href=\"#multi-stage-builds\" aria-label=\"multi stage builds permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi stage builds</h2>\n<p>Hey, we're already half-way to ridiculous, let's make our image EVEN SMALLER. Technically we only need <code class=\"language-text\">npm</code> to build our app, right? We don't actually need it to run our app. Docker allows you to have what it called multistage builds, we it uses one container to build your app and another to run it. This can be useful if you have big dependencies to build your app but you don't need those dependencies to actually run the app. A C++ or Rust app might be a good example of that: they need big tool chains to compile the apps but the resulting binaries are smaller and don't need those tools to actually run them. Or one perhaps more applicable to you is that you don't need the TypeScript or Sass compiler in production, just the compiled files. We'll actually do that here in a sec, but let's start here with eliminating <code class=\"language-text\">npm</code>.</p>\n<p>Make a new Dockerfile, call it <code class=\"language-text\">multi-node.Dockerfile</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># build stage</span>\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n<span class=\"token keyword\">WORKDIR</span> /build\n<span class=\"token keyword\">COPY</span> package<span class=\"token punctuation\">-</span>lock.json package.json ./\n<span class=\"token keyword\">RUN</span> npm ci\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token comment\"># runtime stage</span>\n<span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>3.10\n<span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update nodejs\n<span class=\"token keyword\">RUN</span> addgroup <span class=\"token punctuation\">-</span>S node &amp;&amp; adduser <span class=\"token punctuation\">-</span>S node <span class=\"token punctuation\">-</span>G node\n<span class=\"token keyword\">USER</span> node\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=0 /build .\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Notice we have have two <code class=\"language-text\">FROM</code> instructions. This is how you can tell it's multistage. The last container made will be the final one that gets labeled and shipped. Notice we're starting in Ubuntu which one we use since we're not going to ship this container so we can use the kitchen sink to build it before it copying it to a smaller container.</p>\n<p>After building everything in the build stage (you can have more than two stages by the way) we move on to the runtime container. In this one we're using Alpine due its size and security benefits. Everything else looks similar to what we were doing before, just now we're going to be copying from the build container instead of the host machine.</p>\n<p>The two real key differences are that we don't <code class=\"language-text\">apk add npm</code> and we're doing <code class=\"language-text\">COPY --from=0</code> which means we're copying from the first stage. As you may imagine, this means you can copy from any previous stage or if you leave <code class=\"language-text\">--from</code> off it'll come from the host machine.</p>\n<p>So try it now!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build -t multi-node -f multi-node.Dockerfile <span class=\"token builtin class-name\">.</span>\ndocker run -p <span class=\"token number\">3000</span>:3000 multi-node</code></pre></div>\n<p>Still works! And our container size is down to a cool 39MB as compared to 56MB when we included npm, 86MB when we used <code class=\"language-text\">node:alpine</code> and 913MB when we used <code class=\"language-text\">node:latest</code>.</p>\n<p>Pretty amazing, right? Honestly, how worth is it doing micro optimization like this? Not very. We had to do a decent amount to shave 40MB off the final size and now we're stuck maintaining it. I'd rather just start with <code class=\"language-text\">FROM node:alpine</code> and call it a day. We get all their wisdom for free and we're not stuck with a longer Dockerfile than we need. But it is definitely worth going from 913MB to 86MB!</p>","frontmatter":{"path":"/going-to-production","title":"Going to Production","order":4}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":1,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2,"path":"/docker","title":"Intro to Docker"}}},{"node":{"frontmatter":{"order":2,"path":"/lxc-lxd","title":"lxc & lxd"}}},{"node":{"frontmatter":{"order":3,"path":"/dockerfile","title":"The Dockerfile"}}},{"node":{"frontmatter":{"order":4,"path":"/going-to-production","title":"Going to Production"}}},{"node":{"frontmatter":{"order":5,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/volumes-and-bind-mounts","title":"Volumes and Bind Mounts"}}},{"node":{"frontmatter":{"order":7,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":8,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":9,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":10,"path":"/buildah-podman","title":"Non-Docker Containers: Buildah and Podman"}}},{"node":{"frontmatter":{"order":11,"path":"/kubernetes","title":"Kubernetes, Swarm, Mesos, and Beyond"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}