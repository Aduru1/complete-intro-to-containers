{"componentChunkName":"component---src-templates-lesson-template-js","path":"/kubernetes","webpackCompilationHash":"2609c4b3d6818aafed4b","result":{"data":{"markdownRemark":{"html":"<p>I like to tell people that containers are containers are the \"simple\" (simple is a relative term here) part and Kubernetes is the \"hard\" (hard isn't relative; Kubernetes is really hard) part. So if this feels hard, it's because it is.</p>\n<p>NOTE: Because Kubernetes is long, it's often abbreviates at k8s (k then eight letters then s.)</p>\n<p>So let's talk about use cases. Containers by themselves are useful for many, many use cases like production apps, machine learning, setting up environments, developer environments, and one-off experimentations. Kubernetes builds on containers (read: you need to know containers to use Kubernetes.) Kubernetes is a container orchestration tool. It allows you to manage large, complicated clusters of containers to multiple different hosts. It's a complicated tool that solves complicated problems. As such, we are going to do a hello world so you can understand what it is, what it can do, and then leave you to explore more on your own.</p>\n<p>So let's go over a few fundamental concepts here.</p>\n<ul>\n<li>The <strong>master</strong> is a server that coordinates everything else. This is the brain on of your cluster. Some cloud providers actually won't charge you to run the master.</li>\n<li><strong>Nodes</strong> (not to be confused with Node.js) are the worker servers that are actually going to be running your containers. One node can one or multiple containers. If you're running machine learning and you need big, beefy servers to churn through the learning, your node may only run one container. If you're running a Node.js server like we are, you'll have many containers on one node.</li>\n<li>Technically, a Node is just a deploy target. It could itself be a VM or a container, or as we said it could be a metal-and-silicon server. It's not really important. Just think of it as a destination for containers.</li>\n<li>A <strong>pod</strong> is bascially an atom to a cluster: it's a thing that can't be divided and thus needs to be deployed together. Imagine if you had several types of containers that all worked together as one unit and wouldn't work without each other. In this case, you'd put those into a pod. In many cases and what we're going to do today is do one-container-one-pod. Our app stands alone and thus can be deployed independently. We'll keep the MongoDB pod and app pod separate because they can scale individually.</li>\n<li>A <strong>service</strong> is a group of pods that make up one backend (services can be other things but bear with me for a second), so to speak. Think one microservice is a group of microservices. Pods are scaling up and down all the time and thus it's unreliable to rely on a single pod's IP. So if I tell the User service to rely on this specific IP for the Admin service, that IP might disappear as that pod is scalled up and down. Enter services. This is a reliable entry point so that these services can talk to each other independent of the relative scale of each other. Like you can have one-container-one-pod, you can have one-pod-one-service as well which means you can have one-container-one-pod-one-service. Services can be more than a backend, they can machine learning nodes, database, caches, etc.</li>\n<li>A <strong>deployment</strong> is where you describe what you want the state of your pods to be and then Kubernetes works to get your cluster into that state.</li>\n</ul>\n<p>Here's the sad part: doing this in the Windows subsystem for Linux is tough. If you're following along in Windows, I'd say just grab a coffee and watch how this works. It's not important that you actually do this. If you're comfortable in PowerShell, it works well from there or if you can connect to a true Linux VM, it'll work well from there too. Otherwise, just relax while I do this from macOS.</p>\n<p>So you're going to need at least one new CLI: <code class=\"language-text\">kubectl</code>. <code class=\"language-text\">kubectl</code> (<a href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl/\">see here for how to install</a>) is the tool that allows you to control <em>any</em> Kubernetes cluster, be it local or in the cloud. It's the single unified CLI for managing Kubernetes.</p>\n<p>After that you, you need to make a choice between <code class=\"language-text\">minikube</code> and using Docker Desktop's built in Kubernetes support. If it's all the same to you, I'd suggest using Docker Desktop's because it's easier to use.</p>\n<ul>\n<li>Docker Desktop ships with very simple Kubernetes support. It's nice to learn on but has some limitations. If you need to do more complicated things, get minikube. To enable Kubernetes on Docker Desktop, open the preferences of Docker Desktop, navigate to the Kubernetes tab, enable it, accept when it asks when if it can restart itself, and then wait a few minutes.</li>\n<li><code class=\"language-text\">minikube</code> (<a href=\"https://kubernetes.io/docs/tasks/tools/install-minikube/\">see here for how to install</a>) is a development tool to get your Kubernetes cluster running on your local computer. You will only ever use this locally.</li>\n</ul>\n<p>You can have both installed, by the way. These will be called <strong>contexts</strong>. To switch between the two, you can <code class=\"language-text\">kubectl config use-context minikube</code> or <code class=\"language-text\">kubectl config use-context docker-desktop</code>. You can also shorten <code class=\"language-text\">use-context</code> to <code class=\"language-text\">use</code>.</p>\n<p>If you're using minikube, make sure you run <code class=\"language-text\">minikube start</code>. If you're using Docker Desktop, it should be started already. Do a <code class=\"language-text\">kubectl cluster-info</code> to make sure. To see your nodes, run <code class=\"language-text\">kubectl cluster-info</code>. You should see a master node running.</p>\n<h2 id=\"kompose\"><a href=\"#kompose\" aria-label=\"kompose permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Kompose</h2>\n<p>Next tool we're going to use is one called <a href=\"https://kompose.io/\">Kompose</a>. I'm showing you this tool because it's normally how I start out with Kubernetes. Kompose converts a docker-compose.yml configuration to a Kubernetes configuration. I find this to much more approachable than starting with the myriad configurations you need to get Kubernetes going.</p>\n<p><a href=\"https://kompose.io/installation/\">Click here</a> to see how to install Kompose on your platform.</p>\n<p>So first let's modify our docker-compose.yml a bit to make it work for Kompose.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> btholt/node<span class=\"token punctuation\">-</span>app <span class=\"token comment\"># change build to image</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"3000:3000\"</span>\n    <span class=\"token key atrule\">links</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> db\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">kompose.service.type</span><span class=\"token punctuation\">:</span> LoadBalancer <span class=\"token comment\"># need this label for Kubernetes</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_CONNECTION_STRING</span><span class=\"token punctuation\">:</span> mongodb<span class=\"token punctuation\">:</span>//db<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n  <span class=\"token key atrule\">db</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo<span class=\"token punctuation\">:</span><span class=\"token number\">3</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"27017\"</span> <span class=\"token comment\"># explicitly expose the port</span></code></pre></div>\n<p>Kompose (as of writing) doesn't have a way to easily use local images without pushing it to Docker Hub. If you want to use your own image, add back your <code class=\"language-text\">build: .</code> line and call the image something like <code class=\"language-text\">image: &lt;your Docker Hub username&gt;/node-app</code> and make sure you're logged into the Docker CLI via <code class=\"language-text\">docker login</code>. I've built the image that we've been building together and pushed it to <code class=\"language-text\">btholt/node-app</code> so feel free to just use mine. It's the same code.</p>\n<p>We add the <code class=\"language-text\">LoadBalancer</code> label so that Kubernetes will know to expose this particular service to the outside world. What this actually does for you is it spins up a loadbalancer that will distribute the load amongst all of your running pods. Do note tha this one of three ways to expose a service to outside world (by default everything is only expose internally). The other two are NodePort and using an ingress controller. <a href=\"https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0\">This is a great explainer</a> if you're curious. For now LoadBalancer is perfect.</p>\n<p>Lastly, we need to explicit about the port MongoDB exposes. Locally Docker was able to take care of it but Kubernetes needs us to be super explicity of what's exposed and what's not.</p>\n<p>Okay, so now, a hack. Kompose expects kubectl to be listening on port 8080. We need to do that because it doesn't by default. So run <code class=\"language-text\">kubectl proxy --port=8080</code> and leave that running. You may need to open another terminal while that runs or run that last command in the background.</p>\n<p>Now, you should be able to run <code class=\"language-text\">kompose up</code> and access your app on <a href=\"http://localhost:3000\"><code class=\"language-text\">localhost:3000</code></a>. Congrats! You're running Kuberenetes!</p>\n<p>To get a bird's eye view of everything running, run <code class=\"language-text\">kubectl get all</code> to see everything happening.</p>\n<p>Let's do some Kubernetes magic now. Run <code class=\"language-text\">kubectl scale --replicas=5 deployment/web</code> and run <code class=\"language-text\">kubectl get all</code>. Just like that, you have five instances of our Node.js app running and Kubernetes smartly routing traffic to each. If one of them becomes unhealthy, Kubernetes will automatically tear it down and spin up a new one. By setting up Kubernetes, you get a lot of cool stuff for free. If you're computer is starting to warm up, feel free to run <code class=\"language-text\">kubectl scale --replicas=1 deployment/web</code> to scale down.</p>\n<p>Once you're done toying, run <code class=\"language-text\">kubectl delete all --all</code>. This will tear down everything.</p>\n<h2 id=\"convert\"><a href=\"#convert\" aria-label=\"convert permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Convert</h2>\n<p>We did all of this from a docker-compose.yml file but that's just to get you started. What you want are the actual Kubernetes configuration files. To get those, run <code class=\"language-text\">kompose convert</code> which will spit out all of the various configurations you'll need for the services and deployments. I'm not going to get into today these configurations. Kubernetes is very powerful and has many knobs and levers. For now you can see what Kompose generates for you.</p>\n<h2 id=\"to-the-cloud\"><a href=\"#to-the-cloud\" aria-label=\"to the cloud permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>To the cloud!</h2>\n<p>What's super fun is that kubectl is the same tool you'd use to control your production deployment. So everything you just learn would work against Azure, AWS, GCP, etc. All you have to do is change the context from minikube or docker-desktop to Azure, AWS, or GCP. I'm not going to do that but I'll drop the tutorials here so you can play around yourself. Do note these are often not free and if you're not careful, Kubernetes can get expensive!</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough\">Azure AKS</a></li>\n<li><a href=\"https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html\">Amazon EKS</a></li>\n<li><a href=\"https://cloud.google.com/kubernetes-engine/docs/quickstart\">Google GKE</a></li>\n</ul>","frontmatter":{"path":"/kubernetes","title":"Kubernetes","order":12}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":3,"path":"/lxc-lxd","title":"lxc & lxd"}}},{"node":{"frontmatter":{"order":4,"path":"/docker","title":"Intro to Docker"}}},{"node":{"frontmatter":{"order":5,"path":"/dockerfile","title":"The Dockerfile"}}},{"node":{"frontmatter":{"order":6,"path":"/going-to-production","title":"Going to Production"}}},{"node":{"frontmatter":{"order":7,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":8,"path":"/volumes-and-bind-mounts","title":"Volumes and Bind Mounts"}}},{"node":{"frontmatter":{"order":9,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":10,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":11,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":12,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":13,"path":"/buildah-podman","title":"Non-Docker Containers: Buildah and Podman"}}},{"node":{"frontmatter":{"order":14,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}