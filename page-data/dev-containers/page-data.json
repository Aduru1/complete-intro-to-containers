{"componentChunkName":"component---src-templates-lesson-template-js","path":"/dev-containers","webpackCompilationHash":"1c2e0784c81606168636","result":{"data":{"markdownRemark":{"html":"<p>So far we've talking about taking an app and using containers to prepare the apps to run. This is an obvious use case for them and one you're going to use a lot. But let's talk about a different use case for them: building development environments for your apps.</p>\n<p>Let's paint a picture. Let's say you got a new job with a company and they're a Ruby shop (if you know Ruby, pretend you don't for a sec.) When you arrive, you're going to be given a very long, likely-out-of-date, complicated README that you're going to have to go look for and struggle to set up the proper version of Ruby, the correct dependencies installed, and that Mercury is in retrograde (just kidding.) Suffice to say, it's a not-fun struggle to get new apps working locally, particularly if it's in a stack that you're not familiar with. Shouldn't there be a better way? There is! (I feel like I'm selling knives on an informercial.)</p>\n<p>Containers! What we can do is define a Dockerfile that sets up all our dependencies so that it's 100% re-createable with zero knowledge of how it works to everyone that approaches it. With bind mounts, we can mount our local code into the container so that we can edit locally and have it propagate into the development container. Let's give it a shot!</p>\n<h2 id=\"hugo\"><a href=\"#hugo\" aria-label=\"hugo permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hugo</h2>\n<p>I'm not a Go developer. Go is a wonderful language with a rich ecosystem, it's just not what I've previously used. As such, Go is not set up on my computer. But happens if I move onto a new project that uses <a href=\"https://gohugo.io/\">Hugo</a>? Hugo is a great static site generation tool written in Go but one I'm not too familiar with. I could spend a decent amount of time getting everything set up â€¦ or I could use a container! After a quick Internet search, I stumbled across the container <a href=\"https://hub.docker.com/r/jguyomard/hugo-builder/\">hugo-builder</a> which has Hugo all ready to go, I just have to bind in my source files. So let's give it a shot!</p>\n<p><a href=\"https://github.com/btholt/hugo-example\">Your new project is here</a>.</p>\n<p>Let's go from zero to running our new project in dev mode in three commands</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/btholt/hugo-example.git\n<span class=\"token builtin class-name\">cd</span> hugo-example/\n<span class=\"token comment\"># you could rewrite the --mount here as -v $PWD:/src</span>\ndocker run --rm -it --mount <span class=\"token assign-left variable\">type</span><span class=\"token operator\">=</span>bind,source<span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>\"</span>,target<span class=\"token operator\">=</span>/src -p <span class=\"token number\">1313</span>:1313 -u hugo jguyomard/hugo-builder hugo server -w --bind<span class=\"token operator\">=</span><span class=\"token number\">0.0</span>.0.0</code></pre></div>\n<p>How cool is this? We're zero to developing in Go in three commands! This is a super useful tool for getting developer environments up and running.</p>\n<p>Notice we didn't copy our files in our files. Why? Well, we need our files to live on our host because we want to edit them locally and then run them in the container, right? If they lived in the container, they'd go away once we shut down the container.</p>\n<h2 id=\"aside-on-nodejs-and-native-dependencies\"><a href=\"#aside-on-nodejs-and-native-dependencies\" aria-label=\"aside on nodejs and native dependencies permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Aside on Node.js and Native Dependencies</h2>\n<p>This also works great for Node.js but there would be a problem here, our dependencies (unless you're running Linux as the host and as the container OS.) Whenever you run <code class=\"language-text\">npm install</code> it'll build you dependencies specifically for whatever OS you're on. This is only a problem if you have dependencies that native code in them (like <code class=\"language-text\">node-sass</code> for example) but it's good to know how to handle this.</p>\n<p>Fastest way is to just ignore everything and run the container as-is. Once you have the container running, just <code class=\"language-text\">docker attach</code> to it and run <code class=\"language-text\">npm install</code> yourself inside of the container. A bit manual (and sort of defeating the purpose of containers) but effective.</p>\n<p>The second option which is a bit gross in its own way to add <code class=\"language-text\">npm install &amp;&amp;</code> to the beginning of the <code class=\"language-text\">CMD</code> of your dev container. This will make it so that the node_modules are installed before starting your server. It's a bit of extra overhead on every restart of the app which can be annoying.</p>\n<h2 id=\"visual-studio-code\"><a href=\"#visual-studio-code\" aria-label=\"visual studio code permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Visual Studio Code</h2>\n<p>As you may imagine, I'm a big fan of Visual Studio Code. And I'm a big fan of investing time to learn your tools very well. If you haven't <a href=\"https://frontendmasters.com/workshops/visual-studio-code/\">Burke Holland's course on Frontend Masters</a> on Visual Studio Code. He as well touches on some of the things we're about to talk about here.</p>\n<p>Visual Studio Code has a relatively recent feature that it can connect to remote environments (remote in the sense as in you're editing files not on your host.) You can use VSCode to connect to remote virtual machines (or really anything that's SSH-able), to WSL (Linux running on Windows), and finally to containers.</p>\n<p>Go ahead and install <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers\">the Remote - Containers</a> extension.</p>\n<p>This takes everything one step further: you can actually set up someone's editor for them when they open your project. You can change settings, add extensions, define debugging, and control the container environment with the remote extension and dev containers. Let's go ahead and give it a shot!</p>\n<p>Make a folder within your static-app project called <code class=\"language-text\">.devcontainer</code>. In there we'll put two files. The first one is the Dockerfile where we'll just set up our dev environment.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node\n<span class=\"token keyword\">RUN</span> npm install <span class=\"token punctuation\">-</span>g eslint prettier</code></pre></div>\n<p>Just need the tools and environment, don't actually need to build anything or put the code in there. Visual Studio Code will handle that automatically. Next make a file inside <code class=\"language-text\">.devcontainer</code> called <code class=\"language-text\">devcontainer.json</code>. The folder name has leading <code class=\"language-text\">.</code>, the the JSON file does not.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Frontend Masters Sample\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dockerFile\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Dockerfile\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"appPort\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"runArgs\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"-u\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"node\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"settings\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"workbench.colorTheme\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Night Owl\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// </span><span class=\"token property\">\"workbench.colorTheme\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hot Dog Stand\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"terminal.integrated.shell.linux\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/bin/bash\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"postCreateCommand\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm install\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"extensions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// </span><span class=\"token string\">\"somekittens.hot-dog-stand\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"sdras.night-owl\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"dbaeumer.vscode-eslint\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"esbenp.prettier-vscode\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>From here, close Visual Studio Code and then reopen the project again. You should see a little prompt asking you if you want to re-open the project in a container. Click yes! If you miss that prompt, click the (normally green) button in the bottom left of VSCode that look sort like <code class=\"language-text\">&gt;&lt;</code> but shoved together. It should have an option to open this project in a dev container.</p>\n<p><strong>NOTE</strong>: if you're on Windows and you're following along with WSL, you'll have to get the project <em>out</em> of WSL before it'll let you re-open it in a container. This will hopefully be a smoother experience in the future. To get into Windows from WSL, click the same <code class=\"language-text\">&gt;&lt;</code> logo in the bottom left and say open in Windows. From there the above instructions should work.</p>\n<p>Couple of key things here:</p>\n<ul>\n<li>We can have two different Dockerfiles for dev and production. We can have one. I generally have two unless they overlap so much they're basically the same.</li>\n<li>We're setting up our colleagues for success by making sure everyone has the correct extensions installed for dev. In this case, I added Prettier and ESLint to my team's environment so they can have instant feedback when they're working.</li>\n<li>We can add settings to their environment (like formatting on save) so that everything just works the same for everyone. No worries: your team can override any of this if it's not for them.</li>\n</ul>\n<p>This whole workflow works for VSCode users only so not everyone will get to take apart of the magic. However, at the end of it all, it's just a container for development environments and they have the Dockerfile. They can still build and run that via the techniques above!</p>\n<p>From here you can get as complicated as you need, setting up memory dumps, tracing, and the like. I leave that as an exercise for you (as I'm not the most knowledgeable on how to do it) but whatever you can do with a bash script can be done by Docker for you!</p>","frontmatter":{"path":"/dev-containers","title":"Using Containers for your Dev Environment","order":8}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":3,"path":"/docker","title":"Intro to Docker"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"The Dockerfile"}}},{"node":{"frontmatter":{"order":5,"path":"/going-to-production","title":"Going to Production"}}},{"node":{"frontmatter":{"order":6,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":7,"path":"/volumes-and-bind-mounts","title":"Volumes and Bind Mounts"}}},{"node":{"frontmatter":{"order":8,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":9,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":10,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":11,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":12,"path":"/buildah-podman","title":"Non-Docker Containers: Buildah and Podman"}}},{"node":{"frontmatter":{"order":13,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}