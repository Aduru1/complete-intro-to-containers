{"componentChunkName":"component---src-templates-lesson-template-js","path":"/multi-stage-builds","webpackCompilationHash":"81c643f50e8a99285311","result":{"data":{"markdownRemark":{"html":"<h2 id=\"multi-stage-builds\"><a href=\"#multi-stage-builds\" aria-label=\"multi stage builds permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi stage builds</h2>\n<p>Hey, we're already half-way to ridiculous, let's make our image EVEN SMALLER. Technically we only need <code class=\"language-text\">npm</code> to build our app, right? We don't actually need it to run our app. Docker allows you to have what it called multistage builds, we it uses one container to build your app and another to run it. This can be useful if you have big dependencies to build your app but you don't need those dependencies to actually run the app. A C++ or Rust app might be a good example of that: they need big tool chains to compile the apps but the resulting binaries are smaller and don't need those tools to actually run them. Or one perhaps more applicable to you is that you don't need the TypeScript or Sass compiler in production, just the compiled files. We'll actually do that here in a sec, but let's start here with eliminating <code class=\"language-text\">npm</code>.</p>\n<p>Make a new Dockerfile, call it <code class=\"language-text\">multi-node.Dockerfile</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># build stage</span>\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>latest\n<span class=\"token keyword\">WORKDIR</span> /build\n<span class=\"token keyword\">COPY</span> package<span class=\"token punctuation\">-</span>lock.json package.json ./\n<span class=\"token keyword\">RUN</span> npm ci\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token comment\"># runtime stage</span>\n<span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>3.10\n<span class=\"token keyword\">RUN</span> apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update nodejs\n<span class=\"token keyword\">RUN</span> addgroup <span class=\"token punctuation\">-</span>S node &amp;&amp; adduser <span class=\"token punctuation\">-</span>S node <span class=\"token punctuation\">-</span>G node\n<span class=\"token keyword\">USER</span> node\n<span class=\"token keyword\">RUN</span> mkdir /home/node/code\n<span class=\"token keyword\">WORKDIR</span> /home/node/code\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=0 <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>chown=node<span class=\"token punctuation\">:</span>node /build .\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Notice we have have two <code class=\"language-text\">FROM</code> instructions. This is how you can tell it's multistage. The last container made will be the final one that gets labeled and shipped. Notice we're starting in Ubuntu which one we use since we're not going to ship this container so we can use the kitchen sink to build it before it copying it to a smaller container.</p>\n<p>After building everything in the build stage (you can have more than two stages by the way) we move on to the runtime container. In this one we're using Alpine due its size and security benefits. Everything else looks similar to what we were doing before, just now we're going to be copying from the build container instead of the host machine.</p>\n<p>The two real key differences are that we don't <code class=\"language-text\">apk add npm</code> and we're doing <code class=\"language-text\">COPY --from=0</code> which means we're copying from the first stage. As you may imagine, this means you can copy from any previous stage or if you leave <code class=\"language-text\">--from</code> off it'll come from the host machine.</p>\n<p>So try it now!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build -t multi-node -f multi-node.Dockerfile <span class=\"token builtin class-name\">.</span>\ndocker run -p <span class=\"token number\">3000</span>:3000 multi-node</code></pre></div>\n<p>Still works! And our container size is down to a cool 39MB as compared to 56MB when we included npm, 86MB when we used <code class=\"language-text\">node:alpine</code> and 913MB when we used <code class=\"language-text\">node:latest</code>.</p>\n<p>Pretty amazing, right? Honestly, how worth is it doing micro optimization like this? Not very. We had to do a decent amount to shave 40MB off the final size and now we're stuck maintaining it. I'd rather just start with <code class=\"language-text\">FROM node:alpine</code> and call it a day. We get all their wisdom for free and we're not stuck with a longer Dockerfile than we need. But it is definitely worth going from 913MB to 86MB!</p>","frontmatter":{"path":"/multi-stage-builds","title":"Multi Stage Builds","order":5.2}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":3.5,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":13,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}